/*
 * generated by Xtext 2.28.0
 */
package life.game.validation

import java.util.Arrays
import life.game.gameDSL.Evolution
import life.game.gameDSL.Expr
import life.game.gameDSL.GameDSLPackage.Literals
import life.game.gameDSL.GoL
import life.game.gameDSL.Grid
import life.game.gameDSL.Initialization
import life.game.gameDSL.LOGICALOPERATOR
import life.game.gameDSL.Pattern
import life.game.gameDSL.Percentage
import life.game.gameDSL.Point
import life.game.gameDSL.Range
import life.game.gameDSL.impl.GameDSLFactoryImpl
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GameDSLValidator extends AbstractGameDSLValidator {
	static var fact = GameDSLFactoryImpl.init;
	
	@Check
	def checkGridNotSmallerThanMin(Grid grid) {
		if (grid.width < 40) {
			error("Min width is 40!", grid, Literals.GRID__WIDTH, -1);
		}
		if (grid.height < 40) {
			error("Min height is 40!", grid, Literals.GRID__HEIGHT, -1);
		}
	}

	@Check
	def addInfoToGrid(Grid grid) {
		info("Farthest coordinate is at x: " + (grid.width-1) + " y: " + (grid.height-1), grid, null, -1);
	}

	def goCheckPoint(Point p, int xMax, int yMax, Point msgPos) {
		if (p.x < 0 || p.x >= xMax) {
			error("Point falls outside of width!", msgPos, Literals.POINT__X, -1);
		}
		if (p.y < 0 || p.y >= yMax) {
			error("Point falls outside of height!", msgPos, Literals.POINT__Y, -1);
		}
	}

	@Check
	def checkPointsNotOutsideGrid(GoL gol) {
		// Default grid size		
		var xSize = 80 as int
		var ySize = 60 as int;
		if (gol.grid !== null) {
			xSize = gol.grid.width;
			ySize = gol.grid.height;
		}

		// For each initialization, go check if it contains points that we can check		
		for (Initialization init : gol.init.list) {
			if (init.getPoints !== null) {
				for (Point p : init.getPoints) {
					goCheckPoint(p, xSize, ySize, p);				
				}	
			}
		}
	}
	
	@Check
	def rangeSmallFirst(Range r) {
		if (r.p1.x > r.p2.x) {
			error("First point x in range is bigger than second point x", r, null, -1);
		}
		if (r.p1.y > r.p2.y) {
			error("First point y in range is bigger than second point y", r, null, -1);
		}
	}
	
	@Check
	def rangeInsideGrid(GoL gol) {
		// Default grid size		
		var xSize = 80 as int
		var ySize = 60 as int;
		if (gol.grid !== null) {
			xSize = gol.grid.width;
			ySize = gol.grid.height;
		}
		
		// For each initialization, go check if it contains a range that we can check		
		for (Initialization init : gol.init.list) {
			if (init.getRanges !== null) {
				for (Range r : init.getRanges) {
					goCheckPoint(r.p1, xSize, ySize, r.p1);
					goCheckPoint(r.p2, xSize, ySize, r.p2);
				}
			}
		}
	}
	
	@Check
	def checkPatternsInGrid(GoL gol) {
		// Default grid size		
		var xSize = 80 as int
		var ySize = 60 as int;
		if (gol.grid !== null) {
			xSize = gol.grid.width;
			ySize = gol.grid.height;
		}

		// For each initialization, go check if it contains points that we can check		
		for (Initialization init : gol.init.list) {
			if (init.getPatterns !== null) {
				for (Pattern p : init.getPatterns) {
					// Check starting point
					goCheckPoint(p.start, xSize, ySize, p.start);

					//Check ending point
					var Point far = fact.createPoint();
					switch (p.pattern) {
						case GLIDER: {
							far.setX(p.start.x+2);
							far.setY(p.start.y+2);
						}
						case BLINKER: {
							far.setX(p.start.x);
							far.setY(p.start.y+2);
						}
						case BLOCK: {
							far.setX(p.start.x+1);
							far.setY(p.start.y+1);
						}
						
					}
					goCheckPoint(far, xSize, ySize, p.start);
					info("End of pattern is at x: " + far.x + " y: " + far.y, p.start, null, -1);
				}	
			}
		}
	}
	
	@Check
	def checkRulesDomainNonZero(Evolution evo) {	
		if (evo.name != "Neighbors:") { return; }

		// Set domain to all true
		var boolean[] domain = #[true,true,true,true,true,true,true,true,true];
		var boolean next;
		var boolean break = false;
		var Expr tmp = evo.expr;
		var Expr cur;
		
		while (!break) {
			domain = #[true,true,true,true,true,true,true,true,true];
			cur = tmp;
			next = false;

			// Continue for all AND's
			while (!next) {
				// For every place in domain, check if its reachable
				for (var i = 0 as int; i < 9; i++) {
					switch(cur.op) {
						case '>=': if (cur.number >= i) { domain.set(i, false); }
						case '>':  if (cur.number > i) { domain.set(i, false); }
						case '<':  if (cur.number < i) { domain.set(i, false); }
						case '<=': if (cur.number <= i) { domain.set(i, false); }
						case '!=': if (cur.number == i) { domain.set(i, false); }
						case '==': if (cur.number == i) {
							if (!domain.get(i)) { Arrays.fill(domain, false); }
							else {Arrays.fill(domain, false); domain.set(i, true); }
						}
					}
				}

				// If there are no more AND's
				if (cur.getOther === null || cur.logOp === LOGICALOPERATOR.OR) {
					// If there are no more reachable places, raise error
					if (!anyTrue(domain)) {
						warning("The given domain is equal to an empty domain", tmp, Literals.EXPR__LOG_OP, -1);
					}

					if (cur.logOp !== LOGICALOPERATOR.OR) {						
						// No more Expr to check in this line, go next
						next = true;
						break = true;
					}

					tmp = cur.getOther();
					domain = #[true,true,true,true,true,true,true,true,true];
				}

				// Check the next Expr after AND
				cur = cur.getOther();
			}
		}
	}

	def boolean anyTrue(boolean[] array) {
    	for(boolean b : array) if(b) return true;
    	return false;
	}

	@Check
	def checkPercentagesPossible(Percentage per) {
		if (per.number < 0) {
			warning("This percentages is negative (program will treat it as 0).", per, Literals.PERCENTAGE__NUMBER, -1);
		}
		else if (per.number > 100) {
			warning("This percentages is over 100 (program will treat it as 100).", per, Literals.PERCENTAGE__NUMBER, -1);
		}
	}
}
