/*
 * generated by Xtext 2.28.0
 */
package life.game.validation

import java.util.Arrays
import life.game.gameDSL.Evolution
import life.game.gameDSL.Expr
import life.game.gameDSL.GameDSLPackage.Literals
import life.game.gameDSL.GoL
import life.game.gameDSL.Grid
import life.game.gameDSL.Initialization
import life.game.gameDSL.Point
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GameDSLValidator extends AbstractGameDSLValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					GameDSLPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	@Check
	def checkGridNotSmallerThanMin(Grid grid) {
		if (grid.width < 40) {
			error("Min width is 40!", grid, Literals.GRID__WIDTH, -1);
		}
		if (grid.height < 40) {
			error("Min height is 40!", grid, Literals.GRID__HEIGHT, -1);
		}
	}
	
//	@Check
//	def checkGridNotTooBig(Grid grid) {
//		if ()
//	}

	@Check
	def checkPointsNotOutsideGrid(GoL gol) {
		// Default grid size		
		var xSize = 80 as int
		var ySize = 60 as int;
		if (gol.grid !== null) {
			xSize = gol.grid.width;
			ySize = gol.grid.height;
		}

		// For each initialization, go check if it contains points that we can check		
		for (Initialization init : gol.init) {
			if (init.getPoints !== null) {
				for (Point p: init.getPoints) {
					if (p.x < 0 || p.x > xSize) {
						error("Point falls outside of width!", p, Literals.POINT__X, -1);
					}
					if (p.y < 0 || p.y > ySize) {
						error("Point falls outside of height!", p, Literals.POINT__Y, -1);
					}					
				}				
			}
		}
	}
	
	@Check
	def checkRulesDomainNonZero(Evolution evo) {	
		// Set domain to all true
		var boolean[] domain = #[true,true,true,true,true,true,true,true,true];
		var boolean next;
		var Expr cur;

		for (Expr tmp : evo.exprs) {
			domain = #[true,true,true,true,true,true,true,true,true];
			cur = tmp;
			next = false;

			// Continue for all AND's
			while (!next) {
				// For every place in domain, check if its reachable
				for (var i = 0 as int; i < 9; i++) {
					switch(cur.op) {
						case '>=': if (cur.number >= i) { domain.set(i, false); }
						case '>':  if (cur.number > i) { domain.set(i, false); }
						case '<':  if (cur.number < i) { domain.set(i, false); }
						case '<=': if (cur.number <= i) { domain.set(i, false); }
						case '!=': if (cur.number == i) { domain.set(i, false); }
						case '==': if (cur.number == i) {
							if (!domain.get(i)) { Arrays.fill(domain, false); }
							else {Arrays.fill(domain, false); domain.set(i, true); }
						}
					}
				}

				// If there are no more AND's
				if (cur.getOther === null) {
					// If there are no more reachable places, raise error
					if (!anyTrue(domain)) {
						error("The given domain is equal to an empty domain", tmp, null, -1);
					}

					// No more Expr to check in this line, go next
					next = true;
				}

				// Check the next Expr after AND
				cur = cur.getOther();
			}
		}
	}

	def boolean anyTrue(boolean[] array) {
    	for(boolean b : array) if(b) return true;
    	return false;
	}
}
